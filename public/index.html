<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Échecs Atomiques Pro</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-5px); }
      75% { transform: translateX(5px); }
    }
    .shake-error { animation: shake 0.2s ease-in-out 0s 2; }
    .chess-piece { font-family: "Arial", sans-serif; user-select: none; }
  </style>
  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
    import { getFirestore, doc, setDoc, getDoc, onSnapshot, updateDoc, serverTimestamp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';
    import { getAuth, signInAnonymously } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';

    const firebaseConfig = {
        apiKey: "AIzaSyCJc2nvexdOTAnwyGydexLYzdF0CmdTbg8",
        authDomain: "atomic-chess-221b3.firebaseapp.com",
        projectId: "atomic-chess-221b3",
        storageBucket: "atomic-chess-221b3.firebasestorage.app",
        messagingSenderId: "1005991526828",
        appId: "1:1005991526828:web:4b3f6e158ac94ecd443a09"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const auth = getAuth(app);

    let board = createInitialBoard();
    let selectedSquare = null;
    let currentPlayer = 'white';
    let explosions = [];
    let gameOver = null;
    let moveHistory = [];
    let gameMode = 'menu';
    let gameCode = '';
    let userId = null;
    let playerColor = null;
    let opponentConnected = false;
    let unsubscribe = null;
    let lastMove = null;
    let kingMoved = { white: false, black: false };
    let rookMoved = { whiteKingSide: false, whiteQueenSide: false, blackKingSide: false, blackQueenSide: false };

    const pieceSymbols = {
      'k': '♚', 'q': '♛', 'r': '♜', 'b': '♝', 'n': '♞', 'p': '♟',
      'K': '♚', 'Q': '♛', 'R': '♜', 'B': '♝', 'N': '♞', 'P': '♟'
    };

    signInAnonymously(auth).then(result => userId = result.user.uid);

    function createInitialBoard() {
      return [
        ['r','n','b','q','k','b','n','r'],
        ['p','p','p','p','p','p','p','p'],
        [null,null,null,null,null,null,null,null],
        [null,null,null,null,null,null,null,null],
        [null,null,null,null,null,null,null,null],
        [null,null,null,null,null,null,null,null],
        ['P','P','P','P','P','P','P','P'],
        ['R','N','B','Q','K','B','N','R']
      ];
    }

    function isWhitePiece(piece) { return piece && piece === piece.toUpperCase(); }
    function getPieceColor(piece) { return isWhitePiece(piece) ? 'white' : 'black'; }

    // --- LOGIQUE DE DÉPLACEMENT ET SÉCURITÉ ---

    function isSquareAttacked(currentBoard, targetRow, targetCol, defenderColor) {
      const attackerColor = defenderColor === 'white' ? 'black' : 'white';
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          const piece = currentBoard[r][c];
          if (piece && getPieceColor(piece) === attackerColor) {
            // Utilisation de isValidMove simple sans récursion de sécurité pour les tests d'attaque
            if (checkBasicMove(currentBoard, [r, c], [targetRow, targetCol], piece, true)) return true;
          }
        }
      }
      return false;
    }

    function checkBasicMove(currentBoard, from, to, piece, ignoreSafety = false) {
      const [fR, fC] = from;
      const [tR, tC] = to;
      const rowDiff = Math.abs(tR - fR);
      const colDiff = Math.abs(tC - fC);
      const type = piece.toLowerCase();
      const target = currentBoard[tR][tC];

      if (type === 'p') {
        const dir = isWhitePiece(piece) ? -1 : 1;
        if (ignoreSafety) { // Cas où on teste si un pion attaque une case (capture)
           return tR === fR + dir && colDiff === 1;
        }
        if (fC === tC && !target) {
          if (tR === fR + dir) return true;
          if (fR === (isWhitePiece(piece) ? 6 : 1) && tR === fR + 2 * dir && !currentBoard[fR + dir][fC]) return true;
        }
        if (colDiff === 1 && tR === fR + dir && (target || canCaptureEnPassant(currentBoard, from, to))) return true;
        return false;
      }

      if (type === 'n') return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);
      if (type === 'b') return rowDiff === colDiff && isPathClear(currentBoard, from, to);
      if (type === 'r') return (fR === tR || fC === tC) && isPathClear(currentBoard, from, to);
      if (type === 'q') return (rowDiff === colDiff || fR === tR || fC === tC) && isPathClear(currentBoard, from, to);
      if (type === 'k') return rowDiff <= 1 && colDiff <= 1;
      return false;
    }

    function canCastle(currentBoard, color, side) {
      if (kingMoved[color]) return false;
      const row = color === 'white' ? 7 : 0;
      
      // 1. Interdit si le Roi est en échec
      if (isSquareAttacked(currentBoard, row, 4, color)) return false;
      
      if (side === 'kingside') {
        if (rookMoved[color + 'KingSide'] || currentBoard[row][5] || currentBoard[row][6]) return false;
        // 2. Interdit si les cases traversées sont attaquées
        if (isSquareAttacked(currentBoard, row, 5, color) || isSquareAttacked(currentBoard, row, 6, color)) return false;
        return true;
      } else {
        if (rookMoved[color + 'QueenSide'] || currentBoard[row][1] || currentBoard[row][2] || currentBoard[row][3]) return false;
        if (isSquareAttacked(currentBoard, row, 3, color) || isSquareAttacked(currentBoard, row, 2, color)) return false;
        return true;
      }
    }

    function isMoveSafe(currentBoard, from, to, piece) {
      const myColor = getPieceColor(piece);
      const futureBoard = getSimulatedBoard(currentBoard, from, to, piece);
      if (!findKing(futureBoard, myColor === 'white' ? 'black' : 'white')) return true; // Victoire
      const myKingPos = findKing(futureBoard, myColor);
      if (!myKingPos) return false; // Suicide atomique
      return !isSquareAttacked(futureBoard, myKingPos[0], myKingPos[1], myColor); // Échec standard
    }

    function isPathClear(board, from, to) {
      const [fR, fC] = from; const [tR, tC] = to;
      const rStep = tR > fR ? 1 : tR < fR ? -1 : 0;
      const cStep = tC > fC ? 1 : tC < fC ? -1 : 0;
      let currR = fR + rStep; let currC = fC + cStep;
      while (currR !== tR || currC !== tC) {
        if (board[currR][currC]) return false;
        currR += rStep; currC += cStep;
      }
      return true;
    }

    // --- MOTEUR DE JEU ---

    function getSimulatedBoard(currBoard, from, to, piece) {
      let simBoard = currBoard.map(row => [...row]);
      const [fR, fC] = from; const [tR, tC] = to;
      const isCapture = simBoard[tR][tC] !== null;
      const isEP = canCaptureEnPassant(currBoard, from, to);

      if (isCapture || isEP) {
        let target = isEP ? (isWhitePiece(piece) ? [tR + 1, tC] : [tR - 1, tC]) : [tR, tC];
        const { newBoard } = applyAtomicExplosion(simBoard, target);
        simBoard = newBoard;
        simBoard[fR][fC] = null;
      } else {
        simBoard[tR][tC] = piece;
        simBoard[fR][fC] = null;
        if (piece.toLowerCase() === 'k' && Math.abs(tC - fC) === 2) {
          const rCol = tC === 6 ? 7 : 0; const rTo = tC === 6 ? 5 : 3;
          simBoard[fR][rTo] = simBoard[fR][rCol]; simBoard[fR][rCol] = null;
        }
      }
      return simBoard;
    }

    function applyAtomicExplosion(currentBoard, capturePos) {
      const newBoard = currentBoard.map(row => [...row]);
      const [row, col] = capturePos;
      newBoard[row][col] = null;
      const explosionSquares = [[row, col]];
      const neighbors = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];
      neighbors.forEach(([dR, dC]) => {
        const nR = row + dR; const nC = col + dC;
        if (nR >= 0 && nR < 8 && nC >= 0 && nC < 8) {
          const p = newBoard[nR][nC];
          if (p && p.toLowerCase() !== 'p') {
            newBoard[nR][nC] = null;
            explosionSquares.push([nR, nC]);
          }
        }
      });
      return { newBoard, explosionSquares };
    }

    function canCaptureEnPassant(currBoard, from, to) {
      if (!lastMove || currBoard[from[0]][from[1]].toLowerCase() !== 'p') return false;
      const [lFR, lFC] = lastMove.from; const [lTR, lTC] = lastMove.to;
      return lastMove.piece.toLowerCase() === 'p' && Math.abs(lFR - lTR) === 2 && lTR === from[0] && lTC === to[1];
    }

    function findKing(currentBoard, color) {
      const target = color === 'white' ? 'K' : 'k';
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) if (currentBoard[r][c] === target) return [r, c];
      }
      return null;
    }

    function checkGameOver(currentBoard) {
      const wK = findKing(currentBoard, 'white');
      const bK = findKing(currentBoard, 'black');
      if (!wK && !bK) return 'draw';
      if (!wK) return 'black';
      if (!bK) return 'white';
      return null;
    }

    async function handleSquareClick(row, col) {
      if (gameOver) return;
      if (gameMode === 'online' && (currentPlayer !== playerColor || !opponentConnected)) return;

      if (selectedSquare) {
        const [fR, fC] = selectedSquare;
        const movingPiece = board[fR][fC];

        if (row === fR && col === fC) { selectedSquare = null; render(); return; }

        let isMoveValid = false;
        if (movingPiece.toLowerCase() === 'k' && Math.abs(col - fC) === 2) {
            isMoveValid = canCastle(board, getPieceColor(movingPiece), col === 6 ? 'kingside' : 'queenside');
        } else {
            isMoveValid = checkBasicMove(board, selectedSquare, [row, col], movingPiece);
        }

        if (isMoveValid && getPieceColor(movingPiece) === currentPlayer) {
          if (!isMoveSafe(board, selectedSquare, [row, col], movingPiece)) {
            const grid = document.getElementById('chess-grid');
            grid.classList.add('shake-error');
            setTimeout(() => grid.classList.remove('shake-error'), 400);
            selectedSquare = null; render(); return;
          }

          const isCap = board[row][col] !== null;
          const isEP = canCaptureEnPassant(board, selectedSquare, [row, col]);
          const isCastling = movingPiece.toLowerCase() === 'k' && Math.abs(col - fC) === 2;
          
          let newBoard;
          let explosionSquares = [];
          if (isCap || isEP) {
            const target = isEP ? (isWhitePiece(movingPiece) ? [row + 1, col] : [row - 1, col]) : [row, col];
            const result = applyAtomicExplosion(board, target);
            newBoard = result.newBoard; explosionSquares = result.explosionSquares;
            newBoard[fR][fC] = null;
          } else {
            newBoard = board.map(r => [...r]);
            newBoard[row][col] = movingPiece; newBoard[fR][fC] = null;
            if (isCastling) {
              const rCol = col === 6 ? 7 : 0; const rTo = col === 6 ? 5 : 3;
              newBoard[row][rTo] = newBoard[row][rCol]; newBoard[row][rCol] = null;
            }
          }

          // Mise à jour des états de mouvement
          const pCol = getPieceColor(movingPiece);
          if (movingPiece.toLowerCase() === 'k') kingMoved[pCol] = true;
          if (movingPiece.toLowerCase() === 'r') {
             if (fR === 7 && fC === 0) rookMoved.whiteQueenSide = true;
             else if (fR === 7 && fC === 7) rookMoved.whiteKingSide = true;
             else if (fR === 0 && fC === 0) rookMoved.blackQueenSide = true;
             else if (fR === 0 && fC === 7) rookMoved.blackKingSide = true;
          }

          // Promotion auto Reine
          if (movingPiece.toLowerCase() === 'p' && (row === 0 || row === 7)) {
            newBoard[row][col] = isWhitePiece(movingPiece) ? 'Q' : 'q';
          }

          lastMove = { from: selectedSquare, to: [row, col], piece: movingPiece };
          board = newBoard;
          currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
          selectedSquare = null;

          if (explosionSquares.length > 0) {
            explosions = explosionSquares; render();
            setTimeout(() => { explosions = []; render(); }, 600);
          } else { render(); }

          gameOver = checkGameOver(board);
          if (gameMode === 'online') {
             await updateDoc(doc(db, 'games', gameCode), { board: board.flat(), currentPlayer, lastMove, kingMoved, rookMoved });
          }
          if (gameOver) render();
        } else if (board[row][col] && getPieceColor(board[row][col]) === currentPlayer) {
          selectedSquare = [row, col]; render();
        }
      } else if (board[row][col] && getPieceColor(board[row][col]) === currentPlayer) {
        selectedSquare = [row, col]; render();
      }
    }

    async function createGame() {
      const code = Math.floor(100000 + Math.random() * 900000).toString();
      gameCode = code; playerColor = 'white'; gameMode = 'online';
      await setDoc(doc(db, 'games', code), { board: createInitialBoard().flat(), currentPlayer: 'white', playerWhite: userId, playerWhiteActive: serverTimestamp(), kingMoved, rookMoved });
      startSync();
    }

    async function joinGame() {
      const code = document.getElementById('inputCode').value;
      const snap = await getDoc(doc(db, 'games', code));
      if (!snap.exists() || snap.data().playerBlack) return alert("Code invalide ou partie pleine");
      gameCode = code; playerColor = 'black'; gameMode = 'online';
      await updateDoc(doc(db, 'games', code), { playerBlack: userId, playerBlackActive: serverTimestamp() });
      startSync();
    }

    function startSync() {
      unsubscribe = onSnapshot(doc(db, 'games', gameCode), (s) => {
        const d = s.data(); if (!d) return;
        board = []; for(let i=0; i<8; i++) board.push(d.board.slice(i*8, (i+1)*8));
        currentPlayer = d.currentPlayer; lastMove = d.lastMove;
        kingMoved = d.kingMoved; rookMoved = d.rookMoved;
        opponentConnected = playerColor === 'white' ? !!d.playerBlack : !!d.playerWhite;
        gameOver = checkGameOver(board); render();
      });
    }

    function render() {
      const app = document.getElementById('app');
      if (gameMode === 'menu') {
        app.innerHTML = `<div class="min-h-screen bg-slate-900 flex items-center justify-center p-4">
          <div class="bg-slate-800 p-8 rounded-2xl shadow-2xl w-full max-w-md text-center">
            <h1 class="text-4xl font-bold text-white mb-8">☢️ ATOMIC CHESS</h1>
            <button onclick="window.startLocal()" class="w-full bg-purple-600 text-white py-4 rounded-xl font-bold mb-4 hover:bg-purple-700">LOCAL</button>
            <button onclick="window.createGame()" class="w-full bg-blue-600 text-white py-4 rounded-xl font-bold mb-4 hover:bg-blue-700">CRÉER EN LIGNE</button>
            <input type="text" id="inputCode" placeholder="Code" class="w-full p-4 rounded-xl mb-4 text-center font-bold">
            <button onclick="window.joinGame()" class="w-full bg-green-600 text-white py-4 rounded-xl font-bold hover:bg-green-700">REJOINDRE</button>
          </div>
        </div>`;
        return;
      }

      const displayBoard = (playerColor === 'black') ? board.slice().reverse().map(r => r.slice().reverse()) : board;
      const boardHTML = displayBoard.map((row, rIdx) => {
        const actualR = (playerColor === 'black') ? 7 - rIdx : rIdx;
        return row.map((piece, cIdx) => {
          const actualC = (playerColor === 'black') ? 7 - cIdx : cIdx;
          const isLight = (actualR + actualC) % 2 === 0;
          const isSel = selectedSquare && selectedSquare[0] === actualR && selectedSquare[1] === actualC;
          const isExplo = explosions.some(e => e[0] === actualR && e[1] === actualC);
          const color = isWhitePiece(piece) ? '#FFF' : '#000';
          const shadow = isWhitePiece(piece) ? 'drop-shadow(0 2px 2px rgba(0,0,0,0.5))' : 'drop-shadow(0 0 1px rgba(255,255,255,0.8))';
          return `<div onclick="window.handleSquareClick(${actualR}, ${actualC})" 
                 class="w-10 h-10 sm:w-16 sm:h-16 flex items-center justify-center text-3xl sm:text-5xl cursor-pointer
                 ${isLight ? 'bg-amber-100' : 'bg-amber-800'} ${isSel ? 'ring-4 ring-blue-400 z-10' : ''} 
                 ${isExplo ? 'bg-red-500 animate-pulse' : ''}">
                 <span class="chess-piece" style="color: ${color}; filter: ${shadow}">${piece ? pieceSymbols[piece] : ''}</span>
            </div>`;
        }).join('');
      }).join('');

      app.innerHTML = `<div class="min-h-screen bg-slate-900 text-white p-4 flex flex-col items-center">
          <h2 class="text-2xl font-bold mb-4">${gameOver ? 'PARTIE TERMINÉE' : (currentPlayer === 'white' ? 'TOUR : BLANCS ⚪' : 'TOUR : NOIRS ⚫')}</h2>
          ${gameCode ? `<p class="mb-4 bg-slate-800 px-4 py-2 rounded">CODE : <span class="text-yellow-400 font-mono">${gameCode}</span></p>` : ''}
          <div id="chess-grid" class="grid grid-cols-8 border-4 border-slate-700 shadow-2xl">${boardHTML}</div>
          <button onclick="location.reload()" class="mt-8 bg-slate-700 px-6 py-2 rounded-lg">MENU PRINCIPAL</button>
          ${gameOver ? `<div class="fixed inset-0 bg-black/80 flex flex-col items-center justify-center">
             <h1 class="text-5xl font-black text-red-500 mb-8">${gameOver === 'draw' ? 'MATCH NUL' : gameOver.toUpperCase() + ' GAGNE !'}</h1>
             <button onclick="location.reload()" class="bg-white text-black px-12 py-4 rounded-full font-bold">REJOUER</button>
          </div>` : ''}
        </div>`;
    }

    window.startLocal = () => { gameMode = 'local'; render(); };
    window.createGame = createGame;
    window.joinGame = joinGame;
    window.handleSquareClick = handleSquareClick;
    render();
  </script>
</head>
<body><div id="app"></div></body>
</html>