<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>√âchecs Atomiques Pro + Timers Corrig√©s</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px); } 75% { transform: translateX(5px); } }
    .shake-error { animation: shake 0.2s ease-in-out 0s 2; }
    .chess-piece { font-family: "Arial", sans-serif; user-select: none; }
    .history-scroll::-webkit-scrollbar { width: 4px; }
    .history-scroll::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 10px; }
    .move-dot { width: 12px; height: 12px; background-color: rgba(0, 0, 0, 0.2); border-radius: 50%; }
    .capture-ring { width: 40px; height: 40px; border: 4px solid rgba(255, 0, 0, 0.2); border-radius: 50%; }
    .coord { font-size: 10px; font-weight: bold; color: #94a3b8; display: flex; align-items: center; justify-content: center; }
    .timer-box { font-family: 'Courier New', monospace; transition: all 0.3s; background-color: #1e293b; border: 2px solid #334155; }
    .timer-active { border-color: #f59e0b !important; color: #f59e0b !important; box-shadow: 0 0 15px rgba(245, 158, 11, 0.2); }
  </style>
  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
    import { getFirestore, doc, setDoc, getDoc, onSnapshot, updateDoc, serverTimestamp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';
    import { getAuth, signInAnonymously } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';

    const firebaseConfig = {
        apiKey: "AIzaSyCJc2nvexdOTAnwyGydexLYzdF0CmdTbg8",
        authDomain: "atomic-chess-221b3.firebaseapp.com",
        projectId: "atomic-chess-221b3",
        storageBucket: "atomic-chess-221b3.firebasestorage.app",
        messagingSenderId: "1005991526828",
        appId: "1:1005991526828:web:4b3f6e158ac94ecd443a09"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const auth = getAuth(app);

    let board = createInitialBoard();
    let selectedSquare = null;
    let currentPlayer = 'white';
    let explosions = [];
    let gameOver = null;
    let moveHistory = [];
    let gameMode = 'menu';
    let gameCode = '';
    let userId = null;
    let playerColor = null;
    let opponentConnected = false;
    let unsubscribe = null;
    let lastMove = null;
    let kingMoved = { white: false, black: false };
    let rookMoved = { whiteKingSide: false, whiteQueenSide: false, blackKingSide: false, blackQueenSide: false };

    // Gestion du temps
    let selectedTimeLimit = 300; 
    let timers = { white: 300, black: 300 };
    let timerInterval = null;

    const pieceSymbols = {
      'k': '‚ôö', 'q': '‚ôõ', 'r': '‚ôú', 'b': '‚ôù', 'n': '‚ôû', 'p': '‚ôü',
      'K': '‚ôî\uFE0E', 'Q': '‚ôï\uFE0E', 'R': '‚ôñ\uFE0E', 'B': '‚ôó\uFE0E', 'N': '‚ôò\uFE0E', 'P': '‚ôô\uFE0E'
    };

    signInAnonymously(auth).then(result => userId = result.user.uid);

    function createInitialBoard() {
      return [
        ['r','n','b','q','k','b','n','r'],
        ['p','p','p','p','p','p','p','p'],
        [null,null,null,null,null,null,null,null],
        [null,null,null,null,null,null,null,null],
        [null,null,null,null,null,null,null,null],
        [null,null,null,null,null,null,null,null],
        ['P','P','P','P','P','P','P','P'],
        ['R','N','B','Q','K','B','N','R']
      ];
    }

    // --- CORRECTION DU TIMER ---
    function startTimer() {
      if (timerInterval) clearInterval(timerInterval);
      timerInterval = setInterval(() => {
        if (gameOver || (gameMode === 'online' && !opponentConnected)) return;
        
        // On ne d√©cr√©mente QUE le joueur en cours
        timers[currentPlayer]--;

        if (timers[currentPlayer] <= 0) {
          timers[currentPlayer] = 0;
          gameOver = (currentPlayer === 'white' ? 'black' : 'white');
          clearInterval(timerInterval);
        }
        render();
      }, 1000);
    }

    function formatTime(seconds) {
      const min = Math.floor(seconds / 60);
      const sec = seconds % 60;
      return `${min}:${sec.toString().padStart(2, '0')}`;
    }

    function isWhitePiece(piece) { return piece && piece === piece.toUpperCase(); }
    function getPieceColor(piece) { return isWhitePiece(piece) ? 'white' : 'black'; }
    function toAlgebraic(row, col) { return ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'][col] + (8 - row); }

    // Logique de collision/explosion atomique (Inchang√©e)
    function checkBasicMove(currentBoard, from, to, piece, ignoreSafety = false) {
      const [fR, fC] = from; const [tR, tC] = to;
      const rowDiff = Math.abs(tR - fR); const colDiff = Math.abs(tC - fC);
      const type = piece.toLowerCase(); const target = currentBoard[tR][tC];
      if (type === 'p') {
        const dir = isWhitePiece(piece) ? -1 : 1;
        if (ignoreSafety) return tR === fR + dir && colDiff === 1;
        if (fC === tC && !target) {
          if (tR === fR + dir) return true;
          if (fR === (isWhitePiece(piece) ? 6 : 1) && tR === fR + 2 * dir && !currentBoard[fR + dir][fC]) return true;
        }
        if (colDiff === 1 && tR === fR + dir && (target || canCaptureEnPassant(currentBoard, from, to))) return true;
        return false;
      }
      if (type === 'n') return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);
      if (type === 'b') return rowDiff === colDiff && isPathClear(currentBoard, from, to);
      if (type === 'r') return (fR === tR || fC === tC) && isPathClear(currentBoard, from, to);
      if (type === 'q') return (rowDiff === colDiff || fR === tR || fC === tC) && isPathClear(currentBoard, from, to);
      if (type === 'k') return rowDiff <= 1 && colDiff <= 1;
      return false;
    }

    function isPathClear(board, from, to) {
      const [fR, fC] = from; const [tR, tC] = to;
      const rStep = Math.sign(tR - fR); const cStep = Math.sign(tC - fC);
      let currR = fR + rStep; let currC = fC + cStep;
      while (currR !== tR || currC !== tC) {
        if (board[currR][currC]) return false;
        currR += rStep; currC += cStep;
      }
      return true;
    }

    function applyAtomicExplosion(currentBoard, capturePos) {
      const newBoard = currentBoard.map(row => [...row]);
      const [row, col] = capturePos;
      newBoard[row][col] = null;
      const explosionSquares = [[row, col]];
      const neighbors = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];
      neighbors.forEach(([dR, dC]) => {
        const nR = row + dR; const nC = col + dC;
        if (nR >= 0 && nR < 8 && nC >= 0 && nC < 8) {
          const p = newBoard[nR][nC];
          if (p && p.toLowerCase() !== 'p') { newBoard[nR][nC] = null; explosionSquares.push([nR, nC]); }
        }
      });
      return { newBoard, explosionSquares };
    }

    function findKing(currentBoard, color) {
      const target = color === 'white' ? 'K' : 'k';
      for (let r = 0; r < 8; r++) { for (let c = 0; c < 8; c++) if (currentBoard[r][c] === target) return [r, c]; }
      return null;
    }

    function checkGameOver(currentBoard) {
      const wK = findKing(currentBoard, 'white');
      const bK = findKing(currentBoard, 'black');
      if (!wK && !bK) return 'draw';
      if (!wK) return 'black';
      if (!bK) return 'white';
      return null;
    }

    function isMoveSafe(currentBoard, from, to, piece) {
      const myColor = getPieceColor(piece);
      const futureBoard = getSimulatedBoard(currentBoard, from, to, piece);
      if (!findKing(futureBoard, myColor === 'white' ? 'black' : 'white')) return true;
      const myKingPos = findKing(futureBoard, myColor);
      if (!myKingPos) return false;
      const attackerColor = myColor === 'white' ? 'black' : 'white';
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          const p = futureBoard[r][c];
          if (p && getPieceColor(p) === attackerColor) {
            if (checkBasicMove(futureBoard, [r, c], [myKingPos[0], myKingPos[1]], p, true)) return false;
          }
        }
      }
      return true;
    }

    function getSimulatedBoard(currBoard, from, to, piece) {
      let simBoard = currBoard.map(row => [...row]);
      const [fR, fC] = from; const [tR, tC] = to;
      const isCapture = simBoard[tR][tC] !== null;
      if (isCapture) {
        const { newBoard } = applyAtomicExplosion(simBoard, [tR, tC]);
        simBoard = newBoard; simBoard[fR][fC] = null;
      } else {
        simBoard[tR][tC] = piece; simBoard[fR][fC] = null;
      }
      return simBoard;
    }

    function getValidMoves(fromRow, fromCol) {
      const piece = board[fromRow][fromCol];
      const validMoves = [];
      if (!piece || getPieceColor(piece) !== currentPlayer) return [];
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          const target = board[r][c];
          if (target && getPieceColor(target) === currentPlayer) continue;
          if (checkBasicMove(board, [fromRow, fromCol], [r, c], piece) && isMoveSafe(board, [fromRow, fromCol], [r, c], piece)) {
            validMoves.push([r, c]);
          }
        }
      }
      return validMoves;
    }

    async function handleSquareClick(row, col) {
      if (gameOver) return;
      if (gameMode === 'online' && (currentPlayer !== playerColor || !opponentConnected)) return;
      
      const targetPiece = board[row][col];
      if (selectedSquare) {
        const [fR, fC] = selectedSquare;
        const movingPiece = board[fR][fC];
        const validMoves = getValidMoves(fR, fC);
        
        if (validMoves.some(m => m[0] === row && m[1] === col)) {
          const isCap = board[row][col] !== null;
          let moveText = (pieceSymbols[movingPiece].replace('\uFE0E','') || "") + " " + toAlgebraic(row, col) + (isCap ? " üí•" : "");
          
          let newBoard; let explosionSquares = [];
          if (isCap) {
            const result = applyAtomicExplosion(board, [row, col]);
            newBoard = result.newBoard; explosionSquares = result.explosionSquares;
            newBoard[fR][fC] = null;
          } else {
            newBoard = board.map(r => [...r]);
            newBoard[row][col] = movingPiece; newBoard[fR][fC] = null;
          }
          
          board = newBoard;
          moveHistory.push(moveText);
          currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
          selectedSquare = null;
          
          if (explosionSquares.length > 0) {
            explosions = explosionSquares; render();
            setTimeout(() => { explosions = []; render(); }, 600);
          } else { render(); }
          
          gameOver = checkGameOver(board);
          
          if (gameMode === 'online') {
             await updateDoc(doc(db, 'games', gameCode), { board: board.flat(), currentPlayer, moveHistory, timers });
          }
        } else { selectedSquare = null; render(); }
      } else if (targetPiece && getPieceColor(targetPiece) === currentPlayer) {
        selectedSquare = [row, col]; render();
      }
    }

    // --- FIREBASE ET SYNC ---
    async function createGame() {
      const code = Math.floor(100000 + Math.random() * 900000).toString();
      gameCode = code; playerColor = 'white'; gameMode = 'online';
      timers = { white: selectedTimeLimit, black: selectedTimeLimit };
      await setDoc(doc(db, 'games', code), { 
          board: createInitialBoard().flat(), 
          currentPlayer: 'white', 
          playerWhite: userId, 
          timers, 
          moveHistory: [] 
      });
      startSync(); startTimer();
    }

    async function joinGame() {
      const code = document.getElementById('inputCode').value;
      const snap = await getDoc(doc(db, 'games', code));
      if (!snap.exists() || snap.data().playerBlack) return alert("Code invalide");
      gameCode = code; playerColor = 'black'; gameMode = 'online';
      await updateDoc(doc(db, 'games', code), { playerBlack: userId, playerBlackActive: serverTimestamp() });
      startSync(); startTimer();
    }

    function startSync() {
      unsubscribe = onSnapshot(doc(db, 'games', gameCode), (s) => {
        const d = s.data(); if (!d) return;
        board = []; for(let i=0; i<8; i++) board.push(d.board.slice(i*8, (i+1)*8));
        currentPlayer = d.currentPlayer;
        moveHistory = d.moveHistory || [];
        timers = d.timers || timers;
        opponentConnected = playerColor === 'white' ? !!d.playerBlack : !!d.playerWhite;
        gameOver = checkGameOver(board); render();
      });
    }

    function render() {
      const app = document.getElementById('app');
      if (gameMode === 'menu') {
        app.innerHTML = `<div class="min-h-screen bg-slate-900 flex items-center justify-center p-4">
          <div class="bg-slate-800 p-8 rounded-2xl shadow-2xl w-full max-w-md text-center">
            <h1 class="text-4xl font-bold text-white mb-6 italic tracking-tighter">NUCLEAR CHESS</h1>
            <div class="mb-6">
                <p class="text-slate-500 text-xs mb-3 uppercase font-bold">CADENCE DE JEU</p>
                <div class="grid grid-cols-4 gap-2">
                    ${[1, 3, 5, 10].map(m => `
                        <button onclick="window.setTime(${m * 60})" class="py-2 rounded font-bold transition ${selectedTimeLimit === m*60 ? 'bg-yellow-500 text-black' : 'bg-slate-700 text-slate-300 hover:bg-slate-600'}">
                            ${m}m
                        </button>
                    `).join('')}
                </div>
            </div>
            <button onclick="window.startLocal()" class="w-full bg-indigo-600 text-white py-4 rounded-xl font-black mb-4 hover:bg-indigo-700 transition">LOCAL</button>
            <button onclick="window.createGame()" class="w-full bg-blue-600 text-white py-4 rounded-xl font-black mb-4 hover:bg-blue-700 transition">CR√âER EN LIGNE</button>
            <div class="flex gap-2">
                <input type="text" id="inputCode" placeholder="Code" class="flex-1 p-4 rounded-xl text-center font-bold bg-slate-100">
                <button onclick="window.joinGame()" class="bg-emerald-600 text-white px-6 rounded-xl font-black hover:bg-emerald-700">REJOINDRE</button>
            </div>
          </div>
        </div>`;
        return;
      }

      const validMoves = selectedSquare ? getValidMoves(selectedSquare[0], selectedSquare[1]) : [];
      const displayBoard = (playerColor === 'black') ? board.slice().reverse().map(r => r.slice().reverse()) : board;
      const displayRanks = (playerColor === 'black') ? ['1','2','3','4','5','6','7','8'] : ['8','7','6','5','4','3','2','1'];
      const displayFiles = (playerColor === 'black') ? ['h','g','f','e','d','c','b','a'] : ['a','b','c','d','e','f','g','h'];

      let boardHTML = [];
      displayBoard.forEach((row, rIdx) => {
        boardHTML.push(`<div class="coord coord-row">${displayRanks[rIdx]}</div>`);
        row.forEach((piece, cIdx) => {
          const actualR = (playerColor === 'black') ? 7 - rIdx : rIdx;
          const actualC = (playerColor === 'black') ? 7 - cIdx : cIdx;
          const isLight = (actualR + actualC) % 2 === 0;
          const isSel = selectedSquare && selectedSquare[0] === actualR && selectedSquare[1] === actualC;
          const isExplo = explosions.some(e => e[0] === actualR && e[1] === actualC);
          const isPossibleMove = validMoves.some(m => m[0] === actualR && m[1] === actualC);
          boardHTML.push(`<div onclick="window.handleSquareClick(${actualR}, ${actualC})" 
                 class="relative w-[11vw] h-[11vw] sm:w-16 sm:h-16 flex items-center justify-center text-3xl sm:text-5xl cursor-pointer
                 ${isLight ? 'bg-[#eeeed2]' : 'bg-[#769656]'} ${isSel ? 'bg-[#f6f669]' : ''} 
                 ${isExplo ? 'bg-red-500 animate-pulse' : ''}">
                 ${isPossibleMove ? (piece ? `<div class="capture-ring absolute"></div>` : `<div class="move-dot"></div>`) : ''}
                 <span class="chess-piece relative z-10" style="color: ${isWhitePiece(piece) ? '#FFF' : '#000'}; text-shadow: ${isWhitePiece(piece) ? '0 0 2px #000, 0 0 5px rgba(0,0,0,0.5)' : 'none'};">
                    ${piece ? pieceSymbols[piece] : ''}
                 </span>
            </div>`);
        });
      });
      boardHTML.push(`<div></div>`);
      displayFiles.forEach(f => boardHTML.push(`<div class="coord coord-col">${f}</div>`));

      const oppColor = playerColor === 'white' ? 'black' : 'white';
      const myColor = playerColor || 'white';

      app.innerHTML = `
        <div class="min-h-screen bg-slate-900 text-white p-2 flex flex-col items-center justify-center">
          
          <div class="timer-box w-full max-w-[512px] flex justify-between items-center mb-4 px-6 py-3 rounded-xl ${currentPlayer === oppColor ? 'timer-active' : ''}">
            <div class="flex items-center gap-2">
                <div class="w-3 h-3 rounded-full ${oppColor === 'white' ? 'bg-white' : 'bg-black border border-slate-600'}"></div>
                <span class="font-bold text-xs">ADVERSAIRE</span>
            </div>
            <span class="text-3xl font-black">${formatTime(timers[oppColor])}</span>
          </div>

          <div class="flex flex-col lg:flex-row gap-4 items-start">
            <div id="chess-grid" class="grid grid-cols-[20px_repeat(8,1fr)] bg-slate-800 p-1 border-4 border-slate-700 shadow-2xl rounded-lg">
              ${boardHTML.join('')}
            </div>
            
            <div class="w-full lg:w-48 bg-slate-800 rounded-lg p-3 h-32 lg:h-[450px] overflow-hidden flex flex-col">
                <p class="text-[10px] font-bold text-slate-500 mb-2 uppercase">Historique</p>
                <div class="history-scroll overflow-y-auto flex-1 text-xs">
                    ${moveHistory.map((m, i) => i % 2 === 0 ? `<div class="mb-1"><span class="text-slate-600">${Math.floor(i/2)+1}.</span> <b>${m}</b> ${moveHistory[i+1] || ''}</div>` : '').join('')}
                </div>
            </div>
          </div>

          <div class="timer-box w-full max-w-[512px] flex justify-between items-center mt-4 px-6 py-3 rounded-xl ${currentPlayer === myColor ? 'timer-active' : ''}">
            <div class="flex items-center gap-2">
                <div class="w-3 h-3 rounded-full ${myColor === 'white' ? 'bg-white' : 'bg-black border border-slate-600'}"></div>
                <span class="font-bold text-xs uppercase text-indigo-400">Votre tour</span>
            </div>
            <span class="text-3xl font-black">${formatTime(timers[myColor])}</span>
          </div>

          <div class="mt-6 flex gap-3">
            <button onclick="location.reload()" class="bg-slate-700 px-5 py-2 rounded-lg font-bold text-xs">MENU</button>
            ${gameCode ? `<div class="bg-slate-800 px-5 py-2 rounded-lg border border-slate-700 text-xs font-mono text-yellow-500">CODE: ${gameCode}</div>` : ''}
          </div>

          ${gameOver ? `<div class="fixed inset-0 bg-black/95 flex flex-col items-center justify-center z-50 text-center p-6">
             <div class="text-6xl mb-4">‚ò¢Ô∏è</div>
             <h1 class="text-5xl font-black mb-2">${gameOver === 'white' ? 'BLANCS GAGNENT' : 'NOIRS GAGNENT'}</h1>
             <p class="text-slate-400 text-xl mb-8">${timers[currentPlayer] <= 0 ? 'Victoire au temps' : 'Le roi adverse a explos√©'}</p>
             <button onclick="location.reload()" class="bg-white text-black px-12 py-4 rounded-full font-black text-xl hover:bg-yellow-400 transition">REJOUER</button>
          </div>` : ''}
        </div>`;
    }

    window.setTime = (t) => { selectedTimeLimit = t; render(); };
    window.startLocal = () => { gameMode = 'local'; timers = { white: selectedTimeLimit, black: selectedTimeLimit }; startTimer(); render(); };
    window.createGame = createGame;
    window.joinGame = joinGame;
    window.handleSquareClick = handleSquareClick;
    render();
  </script>
</head>
<body><div id="app"></div></body>
</html>